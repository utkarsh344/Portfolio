import {
  __commonJS
} from "./chunk-UXIASGQL.js";

// node_modules/linked-list-typescript/lib/src/index.js
var require_src = __commonJS({
  "node_modules/linked-list-typescript/lib/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LinkedList = class {
      constructor(...values) {
        this._head = this._tail = null;
        this._length = 0;
        if (values.length > 0) {
          values.forEach((value) => {
            this.append(value);
          });
        }
      }
      *iterator() {
        let currentItem = this._head;
        while (currentItem) {
          yield currentItem.value;
          currentItem = currentItem.next;
        }
      }
      [Symbol.iterator]() {
        return this.iterator();
      }
      get head() {
        return this._head ? this._head.value : null;
      }
      get tail() {
        return this._tail ? this._tail.value : null;
      }
      get length() {
        return this._length;
      }
      // Adds the element at a specific position inside the linked list
      insert(val, previousItem, checkDuplicates = false) {
        if (checkDuplicates && this.isDuplicate(val)) {
          return false;
        }
        let newItem = new LinkedListItem(val);
        let currentItem = this._head;
        if (!currentItem) {
          return false;
        } else {
          while (true) {
            if (currentItem.value === previousItem) {
              newItem.next = currentItem.next;
              newItem.prev = currentItem;
              currentItem.next = newItem;
              if (newItem.next) {
                newItem.next.prev = newItem;
              } else {
                this._tail = newItem;
              }
              this._length++;
              return true;
            } else {
              if (currentItem.next) {
                currentItem = currentItem.next;
              } else {
                return false;
              }
            }
          }
        }
      }
      // Adds the element at the end of the linked list
      append(val, checkDuplicates = false) {
        if (checkDuplicates && this.isDuplicate(val)) {
          return false;
        }
        let newItem = new LinkedListItem(val);
        if (!this._tail) {
          this._head = this._tail = newItem;
        } else {
          this._tail.next = newItem;
          newItem.prev = this._tail;
          this._tail = newItem;
        }
        this._length++;
        return true;
      }
      // Add the element at the beginning of the linked list
      prepend(val, checkDuplicates = false) {
        if (checkDuplicates && this.isDuplicate(val)) {
          return false;
        }
        let newItem = new LinkedListItem(val);
        if (!this._head) {
          this._head = this._tail = newItem;
        } else {
          newItem.next = this._head;
          this._head.prev = newItem;
          this._head = newItem;
        }
        this._length++;
        return true;
      }
      remove(val) {
        let currentItem = this._head;
        if (!currentItem) {
          return;
        }
        if (currentItem.value === val) {
          this._head = currentItem.next;
          this._head.prev = null;
          currentItem.next = currentItem.prev = null;
          this._length--;
          return currentItem.value;
        } else {
          while (true) {
            if (currentItem.value === val) {
              if (currentItem.next) {
                currentItem.prev.next = currentItem.next;
                currentItem.next.prev = currentItem.prev;
                currentItem.next = currentItem.prev = null;
              } else {
                currentItem.prev.next = null;
                this._tail = currentItem.prev;
                currentItem.next = currentItem.prev = null;
              }
              this._length--;
              return currentItem.value;
            } else {
              if (currentItem.next) {
                currentItem = currentItem.next;
              } else {
                return;
              }
            }
          }
        }
      }
      removeHead() {
        let currentItem = this._head;
        if (!currentItem) {
          return;
        }
        if (!this._head.next) {
          this._head = null;
          this._tail = null;
        } else {
          this._head.next.prev = null;
          this._head = this._head.next;
          currentItem.next = currentItem.prev = null;
        }
        this._length--;
        return currentItem.value;
      }
      removeTail() {
        let currentItem = this._tail;
        if (!currentItem) {
          return;
        }
        if (!this._tail.prev) {
          this._head = null;
          this._tail = null;
        } else {
          this._tail.prev.next = null;
          this._tail = this._tail.prev;
          currentItem.next = currentItem.prev = null;
        }
        this._length--;
        return currentItem.value;
      }
      first(num) {
        let iter = this.iterator();
        let result = [];
        let n = Math.min(num, this.length);
        for (let i = 0; i < n; i++) {
          let val = iter.next();
          result.push(val.value);
        }
        return result;
      }
      toArray() {
        return [...this];
      }
      isDuplicate(val) {
        let set = new Set(this.toArray());
        return set.has(val);
      }
    };
    exports.LinkedList = LinkedList;
    var LinkedListItem = class {
      constructor(val) {
        this.value = val;
        this.next = null;
        this.prev = null;
      }
    };
    exports.LinkedListItem = LinkedListItem;
  }
});

// node_modules/queue-typescript/lib/src/index.js
var require_src2 = __commonJS({
  "node_modules/queue-typescript/lib/src/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var linked_list_typescript_1 = require_src();
    var Queue = class extends linked_list_typescript_1.LinkedList {
      constructor(...values) {
        super(...values);
      }
      get front() {
        return this.head;
      }
      enqueue(val) {
        this.append(val);
      }
      dequeue() {
        return this.removeHead();
      }
    };
    exports.Queue = Queue;
  }
});
export default require_src2();
//# sourceMappingURL=queue-typescript.js.map
